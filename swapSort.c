//交换排序：每次将排序位置元素（从首位置元素开始）与其后的各个元素作比较，
//若其后的某个元素比该位置上的元素大，则交换二者位置，这样一轮比较下来就确定了该位置上的元素为最小元素；
//然后，从接下来的位置开始重复第二轮的比较，这样就确定了第二个位置上的元素为次小元素；
//同理，以此类推，就可按第一个到最后一个元素从小到大排好序。
//交换排序 ,总共最多比较1+2+...+(len-1)次，时间复杂度为o(n*n),而最理想情况下为o(n) 
void swapSort(int *a, int len) { 
    for(int i=0; i<len; i++) {
        for(int j=i+1; j<len; j++) {
            if(a[i] > a[j]) {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    } 
}
